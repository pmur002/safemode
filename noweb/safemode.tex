\documentclass[a4paper]{article}% ===> this file was generated automatically by noweave --- better not edit it
\usepackage{noweb}
\usepackage{alltt}
\usepackage{amsmath}

\newcommand{\pkg}[1]{{\bf #1}}

\begin{document}
\title{\textbf{A Package for ``safe mode'' R Sessions}}
\author{Paul Murrell}
\date{}
\maketitle
\begin{abstract}
 
  This document describes the R package \pkg{safemode},
  which provides a function to 
  monitor the activity that takes place on the
  console in an R session and issue warnings when expressions
  are evaluated in an inappropriate order.
  
  The document describes both the use of the command and also provides
  a literate version of the function itself.
  
  This package has as its basis the R code from Ross Ihaka's 
  ``A Function for R Session Scripting.''
\end{abstract}

\section{The \texttt{safemode()} Function}

When {\Tt{}safemode()\nwendquote} is invoked, a sub-interpreter is run to process the
user's commands in ``safe mode.''  
When this sub-interpreter is running, the the R
command prompt is changed to {\Tt{}safe>\ \nwendquote} and the continuation
prompt to {\Tt{}safe+\nwendquote}.  The sub-interpreter is exited by
typing the command \verb|q()|.
\begin{quote}
  \begin{verbatim}
> safemode()

safe> 1:10
 [1]  1  2  3  4  5  6  7  8  9 10
 
safe> max(rnorm(100))
[1] 2.592984

safe> q()
\end{verbatim}
\end{quote}
While in ``safe mode,'' expressions are checked to make sure
that the no symbols are ``stale.''  A symbol is stale if
it was assigned a value less recently than one or more of its
dependents.  For example, in the following, the symbol {\Tt{}y\nwendquote}
becomes dependent on {\Tt{}x\nwendquote}, so if {\Tt{}x\nwendquote} is modified, {\Tt{}y\nwendquote} 
becomes stale.

\begin{quote}
  \begin{verbatim}
> safemode()

safe> x <- 1
safe> y <- x + 1
safe> x <- 2
safe> y
[1] 2
Warning message:
In withCallingHandlers(warning(staleWarnMsg(tracked[staleDeps])),  ... :
  Symbol 'y' is stale!
\end{verbatim}
\end{quote}

This is essentially all there is to know about using {\Tt{}safemode()\nwendquote},
other than to note that a {\Tt{}safemode()\nwendquote} command cannot be run from a
{\Tt{}safemode()\nwendquote} sub-interpreter.

\section{Implementation of the \texttt{safemode()} Function}

The code for the {\Tt{}safemode\nwendquote}
function is implemented as a \emph{closure}.  The
support functions it uses are encapsulated in a private environment,
visible only to that function.  The mechanism used is as follows.

\nwfilename{safemode.Rnw}\nwbegincode{1}\sublabel{NW3fNyKO-3xdkHW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-3xdkHW-1}}}\moddef{safemode.R~{\nwtagstyle{}\subpageref{NW3fNyKO-3xdkHW-1}}}\endmoddef\let\nwnotused=\nwoutput{}\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}comments-and-copyright~{\nwtagstyle{}\subpageref{NW3fNyKO-4FQ1cJ-1}}\RA{}
\LA{}initialisation~{\nwtagstyle{}\subpageref{NW3fNyKO-3GtYCJ-1}}\RA{}
safemode <- local(\{
    \LA{}warning state variables~{\nwtagstyle{}\subpageref{NW3fNyKO-4ZejqA-1}}\RA{}
    \LA{}support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}\RA{}
    \LA{}read-eval-print loop~{\nwtagstyle{}\subpageref{NW3fNyKO-2jP4FB-1}}\RA{}
    \LA{}main function~{\nwtagstyle{}\subpageref{NW3fNyKO-or39s-1}}\RA{}
\})
\nwnotused{safemode.R}\nwendcode{}\nwbegindocs{2}\nwdocspar

\subsection{Initialisation}
\label{sec:init}

The \pkg{safemode} package records a database of time stamps
for symbols and a database of dependencies for symbols.

\nwenddocs{}\nwbegincode{3}\sublabel{NW3fNyKO-3GtYCJ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-3GtYCJ-1}}}\moddef{initialisation~{\nwtagstyle{}\subpageref{NW3fNyKO-3GtYCJ-1}}}\endmoddef\let\nwnotused=\nwoutput{}\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwenddeflinemarkup
timeDB <- new.env()
depDB <- new.env()
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

\subsection{The main function}
\label{sec:the-main-function}

The main function, {\Tt{}safemode()\nwendquote},
takes two arguments: whether to print out debugging information
({\Tt{}FALSE\nwendquote} by default) and a file to read input from ({\Tt{}NULL\nwendquote} by default,
which means take input from the command line).  
This function
calls the main workhorse function that
provides a read-eval-print-loop.
\nwenddocs{}\nwbegincode{5}\sublabel{NW3fNyKO-or39s-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-or39s-1}}}\moddef{main function~{\nwtagstyle{}\subpageref{NW3fNyKO-or39s-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwenddeflinemarkup
function(debug=FALSE, infile=NULL) \{
    \LA{}call the read-eval-print-loop~{\nwtagstyle{}\subpageref{NW3fNyKO-nYuTh-1}}\RA{}
    \LA{}shut down~{\nwtagstyle{}\subpageref{NW3fNyKO-2lz4JN-1}}\RA{}
\}
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwendcode{}\nwbegindocs{6}%

The first
argument passed to the {\Tt{}repl()\nwendquote} function is the environment that
the {\Tt{}safemode()\nwendquote} function was called from.  This will typically
be the R global enviroment.  The second argument is a debugging flag.
The third argument is a file to read R code from (or {\Tt{}NULL\nwendquote}).
\nwenddocs{}\nwbegincode{7}\sublabel{NW3fNyKO-nYuTh-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-nYuTh-1}}}\moddef{call the read-eval-print-loop~{\nwtagstyle{}\subpageref{NW3fNyKO-nYuTh-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-or39s-1}}\nwenddeflinemarkup
\nwlinkedidentc{repl}{NW3fNyKO-2jP4FB-1}(sys.parent(), debug, infile)
\nwused{\\{NW3fNyKO-or39s-1}}\nwidentuses{\\{{\nwixident{repl}}{repl}}}\nwindexuse{\nwixident{repl}}{repl}{NW3fNyKO-nYuTh-1}\nwendcode{}\nwbegindocs{8}%

On exit, the main function erases the time stamp and dependency 
databases and returns an
invisible ({\Tt{}NULL\nwendquote}) value.
\nwenddocs{}\nwbegincode{9}\sublabel{NW3fNyKO-2lz4JN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-2lz4JN-1}}}\moddef{shut down~{\nwtagstyle{}\subpageref{NW3fNyKO-2lz4JN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-or39s-1}}\nwenddeflinemarkup
rm(list=ls(timeDB), envir=timeDB)
rm(list=ls(depDB), envir=depDB)
invisible()
\nwused{\\{NW3fNyKO-or39s-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar

\subsection{The read-eval-print loop}
\label{sec:the-read-eval-print-loop}

The {\Tt{}repl()\nwendquote} function takes over the role of the topmost level of
functionality in R.  It reads the lines of text that the user types,
parses them and evaluates the results.  It also has to handle
exceptional conditions such as errors, warnings and user interrupts.

The important strategy employed in this function
is used to accumulate the lines the user types
until a complete expression has been read.  Reading the lines is easy;
it is done with {\Tt{}readline()\nwendquote}.  Checking for a complete expression
is trickier because parsing an incomplete expression trips an error.
These must be caught using the {\Tt{}tryCatch()\nwendquote} mechanism and this
type of error discriminated from other syntax errors.

There is also the problem of user interrupts.  These can occur at any
point in the read-eval-print process. To protect against such
interrupts the whole read-eval-print process is embedded in a loop
whose sole task is to catch and process interrupts.

The general structure of the {\Tt{}repl()\nwendquote} function is shown by the
following function.  Initial values are defined for the
command prompt and the current expression, we determine whether
we are running in batch mode (or interactively), and then the interrupt
catching loop is run.

After exiting ``safe mode'', if we are in bacth mode, there is some
shut down to perform.
\nwenddocs{}\nwbegincode{11}\sublabel{NW3fNyKO-2jP4FB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-2jP4FB-1}}}\moddef{read-eval-print loop~{\nwtagstyle{}\subpageref{NW3fNyKO-2jP4FB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwenddeflinemarkup
\nwlinkedidentc{repl}{NW3fNyKO-2jP4FB-1} <- function(env, debug, infile) \{
    \nwlinkedidentc{prompt}{NW3fNyKO-2jP4FB-1} <- "safe> "
    \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1} <- character()
    if (is.null(infile)) \{
        batch <- FALSE
    \} else \{
        batch <- TRUE
        \LA{}init batch mode~{\nwtagstyle{}\subpageref{NW3fNyKO-3M0wdx-1}}\RA{}
    \}
    repeat \{
        \LA{}interrupt catching~{\nwtagstyle{}\subpageref{NW3fNyKO-1uMRLP-1}}\RA{}
    \}
    if (batch) \{
        \LA{}batch shut down~{\nwtagstyle{}\subpageref{NW3fNyKO-1ObEmC-1}}\RA{}
    \}
\}

\nwindexdefn{\nwixident{repl}}{repl}{NW3fNyKO-2jP4FB-1}\nwindexdefn{\nwixident{cmd}}{cmd}{NW3fNyKO-2jP4FB-1}\nwindexdefn{\nwixident{prompt}}{prompt}{NW3fNyKO-2jP4FB-1}\eatline
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwidentdefs{\\{{\nwixident{cmd}}{cmd}}\\{{\nwixident{prompt}}{prompt}}\\{{\nwixident{repl}}{repl}}}\nwendcode{}\nwbegindocs{12}\nwdocspar
The code inside the {\Tt{}repeat\nwendquote} loop, in the function above, runs
the \emph{repl} and catches any interrupts that occur with a
{\Tt{}tryCatch()\nwendquote} statement.  The statement catches just interrupts and
gives a fresh prompt.
\nwenddocs{}\nwbegincode{13}\sublabel{NW3fNyKO-1uMRLP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1uMRLP-1}}}\moddef{interrupt catching~{\nwtagstyle{}\subpageref{NW3fNyKO-1uMRLP-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-2jP4FB-1}}\nwenddeflinemarkup
ans <- tryCatch(
    repeat \{
        \LA{}parse and evaluate expressions~{\nwtagstyle{}\subpageref{NW3fNyKO-XzPhD-1}}\RA{}
    \}, interrupt = function(x) x)
if (inherits(ans, "interrupt")) \{
    cat("\\nInterrupt!\\n")
    \nwlinkedidentc{prompt}{NW3fNyKO-2jP4FB-1} <- "script> "
    \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1} <- character()
\} else \{
    stop("Interrupt catcher caught non-interrupt")
\}
\nwused{\\{NW3fNyKO-2jP4FB-1}}\nwidentuses{\\{{\nwixident{cmd}}{cmd}}\\{{\nwixident{prompt}}{prompt}}}\nwindexuse{\nwixident{cmd}}{cmd}{NW3fNyKO-1uMRLP-1}\nwindexuse{\nwixident{prompt}}{prompt}{NW3fNyKO-1uMRLP-1}\nwendcode{}\nwbegindocs{14}\nwdocspar

Expressions are read and processed in a loop. A pass through the loop
reads a single line of input with {\Tt{}readline()\nwendquote} and adds it to the
{\Tt{}cmd\nwendquote} buffer (unless we are in batch mode).  
Each line of input is also added to the command line history 
with the {\Tt{}timestamp()\nwendquote} function.

We handle (whole-line) comments as a special case,
immediately discarding them
(or echoing them in batch mode).

Each time a line is added, an attempt is made to
parse the contents of {\Tt{}cmd\nwendquote} and obtain a valid expression for
evaluation. The parse is wrapped in a {\Tt{}tryCatch()\nwendquote} to trap any
parsing errors that occur.  The result of this attempted parse
determines what happens next.

\nwenddocs{}\nwbegincode{15}\sublabel{NW3fNyKO-XzPhD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-XzPhD-1}}}\moddef{parse and evaluate expressions~{\nwtagstyle{}\subpageref{NW3fNyKO-XzPhD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-1uMRLP-1}}\nwenddeflinemarkup
repeat \{
    if (batch) \{
        \LA{}batch read~{\nwtagstyle{}\subpageref{NW3fNyKO-4Qk14X-1}}\RA{}
    \} else \{
        \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1} <- c(\nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1}, readline(\nwlinkedidentc{prompt}{NW3fNyKO-2jP4FB-1}))
        timestamp(\nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1}, prefix="", suffix="", quiet=TRUE)
    \}
    # Handle EOF in batch mode
    if (!length(\nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1})) \{
        return()
    \}
    if (grepl("^#", \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1})) \{
        if (batch) \{
            \LA{}batch comment~{\nwtagstyle{}\subpageref{NW3fNyKO-1r17xi-1}}\RA{}
        \}
        \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1} <- character()
        break
    \}
    ans <- tryCatch(parse(text = \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1}), error = function(e) e)
    \LA{}handle the results of the parse~{\nwtagstyle{}\subpageref{NW3fNyKO-N1orb-1}}\RA{}
\}
\nwused{\\{NW3fNyKO-1uMRLP-1}}\nwidentuses{\\{{\nwixident{cmd}}{cmd}}\\{{\nwixident{prompt}}{prompt}}}\nwindexuse{\nwixident{cmd}}{cmd}{NW3fNyKO-XzPhD-1}\nwindexuse{\nwixident{prompt}}{prompt}{NW3fNyKO-XzPhD-1}\nwendcode{}\nwbegindocs{16}\nwdocspar


The result returned by the {\Tt{}tryCatch()\nwendquote} is either a valid
expression that can be evaluated or an error condition. We branch
depending on the type of result obtained.
\nwenddocs{}\nwbegincode{17}\sublabel{NW3fNyKO-N1orb-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-N1orb-1}}}\moddef{handle the results of the parse~{\nwtagstyle{}\subpageref{NW3fNyKO-N1orb-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-XzPhD-1}}\nwenddeflinemarkup
\LA{}handle the expression~{\nwtagstyle{}\subpageref{NW3fNyKO-3mTANZ-1}}\RA{}
\nwused{\\{NW3fNyKO-XzPhD-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

There are two possible types of error to deal with.  Errors can be
caused by an incomplete parse or by some other type of syntax error.
If the expression is incomplete, we change the prompt to indicate
continuation and return to the top of the loop to fetch another line
of input.  If there was some other type of error, we deal with
the error then we reset the command
prompt and the state of the input buffer.

If there was no error, we have a valid expression.  
We then choose between a number of special cases
(such as quitting ``safe mode'') and the general case of
evaluating the expression typed by the user.  When that is complete,
we reset the command prompt and the state of the command buffer before
continuing on to read the next expression.

\nwenddocs{}\nwbegincode{19}\sublabel{NW3fNyKO-3mTANZ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-3mTANZ-1}}}\moddef{handle the expression~{\nwtagstyle{}\subpageref{NW3fNyKO-3mTANZ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-N1orb-1}}\nwenddeflinemarkup
if (inherits(ans, "error")) \{
    if (\nwlinkedidentc{incompleteParse}{NW3fNyKO-1LAAIJ-4}((ans))) \{
        \nwlinkedidentc{prompt}{NW3fNyKO-2jP4FB-1} <- "safe+ "
    \} else \{
        \nwlinkedidentc{handleParseError}{NW3fNyKO-1LAAIJ-5}(ans)
        \nwlinkedidentc{prompt}{NW3fNyKO-2jP4FB-1} <- "safe> "
        \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1} <- character()
    \}
\} else \{
    \LA{}handle special expression cases~{\nwtagstyle{}\subpageref{NW3fNyKO-3UyNT8-1}}\RA{}
    \LA{}handle the general expression case~{\nwtagstyle{}\subpageref{NW3fNyKO-ujlbC-1}}\RA{}
    \nwlinkedidentc{prompt}{NW3fNyKO-2jP4FB-1} <- "safe> "
    \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1} <- character()
\}
\nwused{\\{NW3fNyKO-N1orb-1}}\nwidentuses{\\{{\nwixident{cmd}}{cmd}}\\{{\nwixident{handleParseError}}{handleParseError}}\\{{\nwixident{incompleteParse}}{incompleteParse}}\\{{\nwixident{prompt}}{prompt}}}\nwindexuse{\nwixident{cmd}}{cmd}{NW3fNyKO-3mTANZ-1}\nwindexuse{\nwixident{handleParseError}}{handleParseError}{NW3fNyKO-3mTANZ-1}\nwindexuse{\nwixident{incompleteParse}}{incompleteParse}{NW3fNyKO-3mTANZ-1}\nwindexuse{\nwixident{prompt}}{prompt}{NW3fNyKO-3mTANZ-1}\nwendcode{}\nwbegindocs{20}\nwdocspar

If the expression was empty (the user idly typed the enter key) we
simply go back to fetch another expression.  If the user typed {\Tt{}q()\nwendquote}
then we exit from the repl and return to the top-level function.  If
for some reason the user tried to invoke {\Tt{}safemode()\nwendquote} 
we issue an error.  (This probably needs
further thought.)

\nwenddocs{}\nwbegincode{21}\sublabel{NW3fNyKO-3UyNT8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-3UyNT8-1}}}\moddef{handle special expression cases~{\nwtagstyle{}\subpageref{NW3fNyKO-3UyNT8-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3mTANZ-1}}\nwenddeflinemarkup
special <- TRUE
if (length(ans) == 0) \{
    if (batch) \{
        \LA{}batch blank line~{\nwtagstyle{}\subpageref{NW3fNyKO-VjREX-1}}\RA{}
    \}
    \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1} <- character()
    break
\} else if (\nwlinkedidentc{isQuitCall}{NW3fNyKO-1LAAIJ-A}(ans)) \{
    return()
\} else if (grepl("^safemode\\\\(",
               deparse(ans[[1]], nlines = 1))) \{
    cat("Error: You can't call safemode() while in \\"safe mode\\"\\n")
    break
\} else \{
    special <- FALSE
\}
\nwused{\\{NW3fNyKO-3mTANZ-1}}\nwidentuses{\\{{\nwixident{cmd}}{cmd}}\\{{\nwixident{isQuitCall}}{isQuitCall}}}\nwindexuse{\nwixident{cmd}}{cmd}{NW3fNyKO-3UyNT8-1}\nwindexuse{\nwixident{isQuitCall}}{isQuitCall}{NW3fNyKO-3UyNT8-1}\nwendcode{}\nwbegindocs{22}\nwdocspar

If none of these special cases hold, we are in the general situation.
We evaluate the expression that the user typed and print the answer.
Note that it is possible for parsing to produce several calls in the
expression returned from the parse.  (Such calls are separated by
semicolons.) To handle the general case, we loop over the elements of
the expression evaluating and printing each one in turn.

After evaluation, a check
is made of whether any new warnings have been issued.  If there were,
the warnings are transferred to the global variable
{\Tt{}last.warning\nwendquote}. There, they can be accessed with calls to the
function {\Tt{}warnings()\nwendquote}.  Finally, a call is made to {\Tt{}displayWarnings()\nwendquote}
to display the warning messages in the correct way.

\nwenddocs{}\nwbegincode{23}\sublabel{NW3fNyKO-ujlbC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-ujlbC-1}}}\moddef{handle the general expression case~{\nwtagstyle{}\subpageref{NW3fNyKO-ujlbC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3mTANZ-1}}\nwenddeflinemarkup
if (!special) \{
    \nwlinkedidentc{renewwarnings}{NW3fNyKO-4ZejqA-1} <<- TRUE
    \nwlinkedidentc{newwarnings}{NW3fNyKO-4ZejqA-1} <<- FALSE
    if (batch) \{
        \LA{}batch expression~{\nwtagstyle{}\subpageref{NW3fNyKO-2EECxy-1}}\RA{}
    \}
    for(e in ans) \{
        \LA{}evaluate expression in safe mode~{\nwtagstyle{}\subpageref{NW3fNyKO-4X48TB-1}}\RA{}
    \}
    if (\nwlinkedidentc{newwarnings}{NW3fNyKO-4ZejqA-1}) \{
        warnings = \nwlinkedidentc{warningCalls}{NW3fNyKO-4ZejqA-1}
        names(warnings) = \nwlinkedidentc{warningMessages}{NW3fNyKO-4ZejqA-1}
        assign("last.warning",
               warnings[1:\nwlinkedidentc{nwarnings}{NW3fNyKO-4ZejqA-1}],
               "package:base")
        \nwlinkedidentc{displayWarnings}{NW3fNyKO-1LAAIJ-9}(\nwlinkedidentc{nwarnings}{NW3fNyKO-4ZejqA-1})
    \}
\}
\nwused{\\{NW3fNyKO-3mTANZ-1}}\nwidentuses{\\{{\nwixident{displayWarnings}}{displayWarnings}}\\{{\nwixident{newwarnings}}{newwarnings}}\\{{\nwixident{nwarnings}}{nwarnings}}\\{{\nwixident{renewwarnings}}{renewwarnings}}\\{{\nwixident{warningCalls}}{warningCalls}}\\{{\nwixident{warningMessages}}{warningMessages}}}\nwindexuse{\nwixident{displayWarnings}}{displayWarnings}{NW3fNyKO-ujlbC-1}\nwindexuse{\nwixident{newwarnings}}{newwarnings}{NW3fNyKO-ujlbC-1}\nwindexuse{\nwixident{nwarnings}}{nwarnings}{NW3fNyKO-ujlbC-1}\nwindexuse{\nwixident{renewwarnings}}{renewwarnings}{NW3fNyKO-ujlbC-1}\nwindexuse{\nwixident{warningCalls}}{warningCalls}{NW3fNyKO-ujlbC-1}\nwindexuse{\nwixident{warningMessages}}{warningMessages}{NW3fNyKO-ujlbC-1}\nwendcode{}\nwbegindocs{24}\nwdocspar

\subsection{Evaluating expressions in ``safe mode''}
\label{sec:safemode}

For each expression, {\Tt{}e\nwendquote}, we determine which symbols need checking,
check for any stale symbols, then evaluate the expression.

Before we evaluate the expression, we deparse it so we have a text
version of the code.

Evaluation is carried out inside a {\Tt{}tryCatchWithWarnings()\nwendquote} call.
This means that any warnings that occur are recorded (in the variables
{\Tt{}warningCalls\nwendquote} and {\Tt{}warningMessages\nwendquote}).  Evaluation also occurs
in the parent environment of the {\Tt{}safemode()\nwendquote} call, {\Tt{}env\nwendquote} (which will
typically be the global environment).  

If there were no errors, we record new time stamps and dependencies
for any symbols assigned in the expression.

\nwenddocs{}\nwbegincode{25}\sublabel{NW3fNyKO-4X48TB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-4X48TB-1}}}\moddef{evaluate expression in safe mode~{\nwtagstyle{}\subpageref{NW3fNyKO-4X48TB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-ujlbC-1}}\nwenddeflinemarkup
\LA{}determine tracked symbols in expression~{\nwtagstyle{}\subpageref{NW3fNyKO-24swck-1}}\RA{}
\LA{}check for stale symbols in expression~{\nwtagstyle{}\subpageref{NW3fNyKO-1i5iWR-1}}\RA{}
code <- deparse(e)                                 
e <- \nwlinkedidentc{tryCatchWithWarnings}{NW3fNyKO-1LAAIJ-8}(withVisible(eval(e,
                                           envir = env)))
if (inherits(e, "error")) \{
    \nwlinkedidentc{handleError}{NW3fNyKO-1LAAIJ-6}(e)
\} else \{
    \nwlinkedidentc{handleValue}{NW3fNyKO-1LAAIJ-7}(e)
    \LA{}record time stamps and dependencies~{\nwtagstyle{}\subpageref{NW3fNyKO-41HQ4C-1}}\RA{}
\}
\nwused{\\{NW3fNyKO-ujlbC-1}}\nwidentuses{\\{{\nwixident{handleError}}{handleError}}\\{{\nwixident{handleValue}}{handleValue}}\\{{\nwixident{tryCatchWithWarnings}}{tryCatchWithWarnings}}}\nwindexuse{\nwixident{handleError}}{handleError}{NW3fNyKO-4X48TB-1}\nwindexuse{\nwixident{handleValue}}{handleValue}{NW3fNyKO-4X48TB-1}\nwindexuse{\nwixident{tryCatchWithWarnings}}{tryCatchWithWarnings}{NW3fNyKO-4X48TB-1}\nwendcode{}\nwbegindocs{26}\nwdocspar

To determine which symbols need to be checked, we use 
{\Tt{}findGlobals()\nwendquote} from the \pkg{codetools} package.
This involves setting up a dummy function (with no arguments)
because {\Tt{}findGlobals()\nwendquote}
only works on closures.  We also can only check symbols for which
we already have a time stamp.

\nwenddocs{}\nwbegincode{27}\sublabel{NW3fNyKO-24swck-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-24swck-1}}}\moddef{determine tracked symbols in expression~{\nwtagstyle{}\subpageref{NW3fNyKO-24swck-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-4X48TB-1}}\nwenddeflinemarkup
dummy <- function() \{\}
body(dummy) <- e
vars <- findGlobals(dummy)
tracked <- vars[vars %in% ls(timeDB)]
\LA{}debug globals~{\nwtagstyle{}\subpageref{NW3fNyKO-2ZXfip-1}}\RA{}
\nwused{\\{NW3fNyKO-4X48TB-1}}\nwendcode{}\nwbegindocs{28}\nwdocspar

If there are any symbols to check, and any of those symbols
are stale, we issue a warning.

\nwenddocs{}\nwbegincode{29}\sublabel{NW3fNyKO-1i5iWR-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1i5iWR-1}}}\moddef{check for stale symbols in expression~{\nwtagstyle{}\subpageref{NW3fNyKO-1i5iWR-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-4X48TB-1}}\nwenddeflinemarkup
if (length(tracked) > 0) \{
    staleDeps <- sapply(tracked, stale)
    if (any(staleDeps)) \{
        withCallingHandlers(warning(staleWarnMsg(tracked[staleDeps])),
                            warning = warningHandler)
    \}
\}
\nwused{\\{NW3fNyKO-4X48TB-1}}\nwendcode{}\nwbegindocs{30}\nwdocspar

To determine whether the expression involved an assignment, we
use {\Tt{}getInputs()\nwendquote} from the \pkg{CodeDepends} package.
If that function determines that there are ``output'' or ``update''
symobls in the expression, then we have an assignment,
so we record a new time stamp (and update the dependencies) for the
symbol that was assigned a new value.
The {\Tt{}get{\_}nanotime()\nwendquote} function from the \pkg{microbenchmark}
package is used to get more accurate timings.

\nwenddocs{}\nwbegincode{31}\sublabel{NW3fNyKO-41HQ4C-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-41HQ4C-1}}}\moddef{record time stamps and dependencies~{\nwtagstyle{}\subpageref{NW3fNyKO-41HQ4C-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-4X48TB-1}}\nwenddeflinemarkup
# test for whether expression was an assignment
sc <- readScript("", txt=code)
info <- scriptInfo(sc)
inputs <- info[[1]]@inputs
outputs <- info[[1]]@outputs
updates <- info[[1]]@updates
\LA{}debug inputs and outputs~{\nwtagstyle{}\subpageref{NW3fNyKO-4Fird-1}}\RA{}
assignment <- FALSE
symbol <- character()
if (length(outputs) > 0) \{
    symbol <- c(symbol, outputs)
    assignment <- TRUE
\}
if (length(updates) > 0) \{
    symbol <- c(symbol, updates)
    assignment <- TRUE    
\}
if (assignment) \{
    for (i in symbol) \{
        assign(i, get_nanotime(), envir=timeDB)
        assign(symbol, tracked, envir=depDB)
    \}
    \LA{}debug time and dependency databases~{\nwtagstyle{}\subpageref{NW3fNyKO-4RCJKm-1}}\RA{}
\}
\nwused{\\{NW3fNyKO-4X48TB-1}}\nwendcode{}\nwbegindocs{32}\nwdocspar

\subsection{Stale symbol support functions}

The functions {\Tt{}age()\nwendquote} and {\Tt{}deps()\nwendquote} provide convenient
access to the time stamp and dependencies databases.

\nwenddocs{}\nwbegincode{33}\sublabel{NW3fNyKO-1LAAIJ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{\relax}{NW3fNyKO-1LAAIJ-2}\nwenddeflinemarkup
age <- function(x) \{
    get(x, timeDB, inherits=FALSE)
\}
deps <- function(x) \{
    get(x, depDB, inherits=FALSE)
\}    
\nwalsodefined{\\{NW3fNyKO-1LAAIJ-2}\\{NW3fNyKO-1LAAIJ-3}\\{NW3fNyKO-1LAAIJ-4}\\{NW3fNyKO-1LAAIJ-5}\\{NW3fNyKO-1LAAIJ-6}\\{NW3fNyKO-1LAAIJ-7}\\{NW3fNyKO-1LAAIJ-8}\\{NW3fNyKO-1LAAIJ-9}\\{NW3fNyKO-1LAAIJ-A}}\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwendcode{}\nwbegindocs{34}\nwdocspar

The {\Tt{}stale()\nwendquote} function finds all dependencies for a symbol
and checks that the symbol is older than all of its dependents,
and that all of its dependents are not stale.

\nwenddocs{}\nwbegincode{35}\sublabel{NW3fNyKO-1LAAIJ-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-2}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{NW3fNyKO-1LAAIJ-1}{NW3fNyKO-1LAAIJ-3}\nwenddeflinemarkup
stale <- function(x) \{
    dependents <- deps(x)
    length(dependents) &&
        (any(age(x) < sapply(dependents, age)) || 
         any(sapply(dependents, stale)))
\}
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwendcode{}\nwbegindocs{36}\nwdocspar

The {\Tt{}staleWarnMsg()\nwendquote} function generates text for a warning message.

\nwenddocs{}\nwbegincode{37}\sublabel{NW3fNyKO-1LAAIJ-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-3}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{NW3fNyKO-1LAAIJ-2}{NW3fNyKO-1LAAIJ-4}\nwenddeflinemarkup
staleWarnMsg <- function(deps) \{
    N <- length(deps)
    if (N == 1) \{
        paste0("Symbol '", deps, "' is stale!")
    \} else if (N == 2) \{
        paste0("Symbols '",
               paste(deps, collapse="' and '"),
               "' are stale!")
    \} else \{
        paste0("Symbols '",
               paste(paste(deps[-N], collapse="', '"),
                     deps[N], sep="', and '"),
               "' are stale!")
    \}
\}
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwendcode{}\nwbegindocs{38}\nwdocspar

\subsection{Parsing support functions}
\label{sec:parsing-support-functions}

An incomplete parse is detected when the result of the parse is an
error that contains the string {\Tt{}"unexpected\ end\ of\ input"\nwendquote}.

\nwenddocs{}\nwbegincode{39}\sublabel{NW3fNyKO-1LAAIJ-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-4}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{NW3fNyKO-1LAAIJ-3}{NW3fNyKO-1LAAIJ-5}\nwenddeflinemarkup
\nwlinkedidentc{incompleteParse}{NW3fNyKO-1LAAIJ-4} <- function(e) \{
    (inherits(e, "error") &&
     grepl("unexpected end of input", e$message))
\}
\nwindexdefn{\nwixident{incompleteParse}}{incompleteParse}{NW3fNyKO-1LAAIJ-4}\eatline
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwidentdefs{\\{{\nwixident{incompleteParse}}{incompleteParse}}}\nwendcode{}\nwbegindocs{40}\nwdocspar
The most complicated support function is the one that handles the
printing of error messages from parsing.  Because the parse is taking
place using a character vector as input, the error messages produced
look rather different from those produced when the parser gets its
input from the console.  This function transforms the error messages
into that form.

\nwenddocs{}\nwbegincode{41}\sublabel{NW3fNyKO-1LAAIJ-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-5}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{NW3fNyKO-1LAAIJ-4}{NW3fNyKO-1LAAIJ-6}\nwenddeflinemarkup
\nwlinkedidentc{handleParseError}{NW3fNyKO-1LAAIJ-5} <- function(e) \{
    msg = strsplit(conditionMessage(e), "\\n")[[1]]
    errortxt = msg[1]
    msg = gsub("[0-9]+: ", "", msg[-c(1, length(msg))])
    msg = msg[length(msg) - 1:0]
    if (length(msg) == 1)
        msg = paste(" in: \\"", msg, "\\"\\n", sep = "")
    else
        msg = paste(" in:\\n\\"",
                    paste(msg, collapse = "\\n"),
                    "\\"\\n", sep = "")
    cat("Error",
        gsub("\\n.*", "",
             gsub("<text>:[0-9]+:[0-9]+", "",
                  errortxt)),
        msg, sep = "")
\}
\nwindexdefn{\nwixident{handleParseError}}{handleParseError}{NW3fNyKO-1LAAIJ-5}\eatline
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwidentdefs{\\{{\nwixident{handleParseError}}{handleParseError}}}\nwendcode{}\nwbegindocs{42}\nwdocspar
\subsection{Input-output support}
\label{sec:input-output-support}

The error messages produced during evaluation are easy to process.  We
simply cat them to the output.

\nwenddocs{}\nwbegincode{43}\sublabel{NW3fNyKO-1LAAIJ-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-6}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{NW3fNyKO-1LAAIJ-5}{NW3fNyKO-1LAAIJ-7}\nwenddeflinemarkup
\nwlinkedidentc{handleError}{NW3fNyKO-1LAAIJ-6} <- function(e) \{
    cat("Error in", deparse(conditionCall(e)),
        ":", conditionMessage(e), "\\n")
\}
\nwindexdefn{\nwixident{handleError}}{handleError}{NW3fNyKO-1LAAIJ-6}\eatline
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwidentdefs{\\{{\nwixident{handleError}}{handleError}}}\nwendcode{}\nwbegindocs{44}\nwdocspar
Printing the values that result from evaluating expressions has one
wrinkle to it.  We have to check the visibility of the result and only
print ``visible'' results.

\nwenddocs{}\nwbegincode{45}\sublabel{NW3fNyKO-1LAAIJ-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-7}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{NW3fNyKO-1LAAIJ-6}{NW3fNyKO-1LAAIJ-8}\nwenddeflinemarkup
\nwlinkedidentc{handleValue}{NW3fNyKO-1LAAIJ-7} <- function(e) \{
    if (e$visible) \{
        print(e$value)
    \}
\}
\nwindexdefn{\nwixident{handleValue}}{handleValue}{NW3fNyKO-1LAAIJ-7}\eatline
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwidentdefs{\\{{\nwixident{handleValue}}{handleValue}}}\nwendcode{}\nwbegindocs{46}\nwdocspar
\subsection{Warning support}
\label{sec:warning-support}

A number of top-level closure variables are used to manage the warning
messages produced by evaluation of expressions.  The following
variables manage the accumulation of error messages.
\begin{flushleft}
  \quad\begin{tabular}{ll}
    {\Tt{}warningCalls\nwendquote} & holds the calls that produced warnings \\
    {\Tt{}warningMessages\nwendquote} & holds the warning messages \\
    {\Tt{}nwarnings\nwendquote} & the number or warnings accumulated \\
    {\Tt{}renewwarnings\nwendquote} & purge the warning list on next warning? \\
    {\Tt{}newwarnings\nwendquote} & has the evaluation produced new warnings
  \end{tabular}
\end{flushleft}

\noindent
The variables are initialised as follows.

\nwenddocs{}\nwbegincode{47}\sublabel{NW3fNyKO-4ZejqA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-4ZejqA-1}}}\moddef{warning state variables~{\nwtagstyle{}\subpageref{NW3fNyKO-4ZejqA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwenddeflinemarkup
\nwlinkedidentc{warningCalls}{NW3fNyKO-4ZejqA-1} <- vector("list", 50)
\nwlinkedidentc{warningMessages}{NW3fNyKO-4ZejqA-1} <- character(50)
\nwlinkedidentc{nwarnings}{NW3fNyKO-4ZejqA-1} <- 0
\nwlinkedidentc{renewwarnings}{NW3fNyKO-4ZejqA-1} <- TRUE
\nwlinkedidentc{newwarnings}{NW3fNyKO-4ZejqA-1} <- FALSE
\nwindexdefn{\nwixident{warningCalls}}{warningCalls}{NW3fNyKO-4ZejqA-1}\nwindexdefn{\nwixident{warningMessages}}{warningMessages}{NW3fNyKO-4ZejqA-1}\nwindexdefn{\nwixident{nwarnings}}{nwarnings}{NW3fNyKO-4ZejqA-1}\nwindexdefn{\nwixident{renewwarnings}}{renewwarnings}{NW3fNyKO-4ZejqA-1}\nwindexdefn{\nwixident{newwarnings}}{newwarnings}{NW3fNyKO-4ZejqA-1}\eatline
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwidentdefs{\\{{\nwixident{newwarnings}}{newwarnings}}\\{{\nwixident{nwarnings}}{nwarnings}}\\{{\nwixident{renewwarnings}}{renewwarnings}}\\{{\nwixident{warningCalls}}{warningCalls}}\\{{\nwixident{warningMessages}}{warningMessages}}}\nwendcode{}\nwbegindocs{48}\nwdocspar
Warnings are trapped by the following two functions.  The effect is to
simply add warnings to the accumulated list of warnings and then call
the built-in {\Tt{}muffleWarning()\nwendquote} restart.
\nwenddocs{}\nwbegincode{49}\sublabel{NW3fNyKO-1LAAIJ-8}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-8}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{NW3fNyKO-1LAAIJ-7}{NW3fNyKO-1LAAIJ-9}\nwenddeflinemarkup
warningHandler <- function(w) \{
    \nwlinkedidentc{newwarnings}{NW3fNyKO-4ZejqA-1} <<- TRUE
    if (\nwlinkedidentc{renewwarnings}{NW3fNyKO-4ZejqA-1}) \{
        \nwlinkedidentc{renewwarnings}{NW3fNyKO-4ZejqA-1} <<- FALSE
        \nwlinkedidentc{nwarnings}{NW3fNyKO-4ZejqA-1} <<- 0
    \}
    n <- \nwlinkedidentc{nwarnings}{NW3fNyKO-4ZejqA-1} + 1
    if (n <= 50) \{
        \nwlinkedidentc{warningCalls}{NW3fNyKO-4ZejqA-1}[[n]] <<- conditionCall(w)
        \nwlinkedidentc{warningMessages}{NW3fNyKO-4ZejqA-1}[n] <<- conditionMessage(w)
        \nwlinkedidentc{nwarnings}{NW3fNyKO-4ZejqA-1} <<- n
    \}
    invokeRestart("muffleWarning")
\}        
\nwlinkedidentc{tryCatchWithWarnings}{NW3fNyKO-1LAAIJ-8} <- function(expr) \{
    withCallingHandlers(tryCatch(expr,
                                 error = function(e) e),
                        warning = warningHandler)
\}
\nwindexdefn{\nwixident{tryCatchWithWarnings}}{tryCatchWithWarnings}{NW3fNyKO-1LAAIJ-8}\eatline
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwidentdefs{\\{{\nwixident{tryCatchWithWarnings}}{tryCatchWithWarnings}}}\nwidentuses{\\{{\nwixident{newwarnings}}{newwarnings}}\\{{\nwixident{nwarnings}}{nwarnings}}\\{{\nwixident{renewwarnings}}{renewwarnings}}\\{{\nwixident{warningCalls}}{warningCalls}}\\{{\nwixident{warningMessages}}{warningMessages}}}\nwindexuse{\nwixident{newwarnings}}{newwarnings}{NW3fNyKO-1LAAIJ-8}\nwindexuse{\nwixident{nwarnings}}{nwarnings}{NW3fNyKO-1LAAIJ-8}\nwindexuse{\nwixident{renewwarnings}}{renewwarnings}{NW3fNyKO-1LAAIJ-8}\nwindexuse{\nwixident{warningCalls}}{warningCalls}{NW3fNyKO-1LAAIJ-8}\nwindexuse{\nwixident{warningMessages}}{warningMessages}{NW3fNyKO-1LAAIJ-8}\nwendcode{}\nwbegindocs{50}\nwdocspar
The {\Tt{}displayWarnings()\nwendquote} function is used to display warnings at the
end of an evaluation.  If there are 10 or fewer messages they are
displayed.  If there are more than 10 messages, the user is told to
inspect them with {\Tt{}warnings()\nwendquote}.  Only the first 50 messages are
stored.

\nwenddocs{}\nwbegincode{51}\sublabel{NW3fNyKO-1LAAIJ-9}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-9}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{NW3fNyKO-1LAAIJ-8}{NW3fNyKO-1LAAIJ-A}\nwenddeflinemarkup
\nwlinkedidentc{displayWarnings}{NW3fNyKO-1LAAIJ-9} <- function(n) \{
    if (n <= 10) \{
        print(warnings())
    \} else if (n < 50) \{
        cat("There were",
            \nwlinkedidentc{nwarnings}{NW3fNyKO-4ZejqA-1},
            "warnings (use warnings() to see them)\\n")
    \} else \{
        cat("There were 50 or more warnings",
            "(use warnings() to see the first 50)\\n")
    \}
\}
\nwindexdefn{\nwixident{displayWarnings}}{displayWarnings}{NW3fNyKO-1LAAIJ-9}\eatline
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwidentdefs{\\{{\nwixident{displayWarnings}}{displayWarnings}}}\nwidentuses{\\{{\nwixident{nwarnings}}{nwarnings}}}\nwindexuse{\nwixident{nwarnings}}{nwarnings}{NW3fNyKO-1LAAIJ-9}\nwendcode{}\nwbegindocs{52}\nwdocspar
\subsection{Debugging support} 
\label{sec:debugging}

If the {\Tt{}debug\nwendquote} flag is set to {\Tt{}TRUE\nwendquote} a variety of 
debugging information is spewed out for each expression.

\nwenddocs{}\nwbegincode{53}\sublabel{NW3fNyKO-2ZXfip-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-2ZXfip-1}}}\moddef{debug globals~{\nwtagstyle{}\subpageref{NW3fNyKO-2ZXfip-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-24swck-1}}\nwenddeflinemarkup
if (debug) \{
    cat(paste("globals: ", paste(vars, collapse=", "), "\\n"))
    cat(paste("tracked: ", paste(tracked, collapse=", "), "\\n"))
\}
\nwused{\\{NW3fNyKO-24swck-1}}\nwendcode{}\nwbegindocs{54}\nwdocspar

\nwenddocs{}\nwbegincode{55}\sublabel{NW3fNyKO-4Fird-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-4Fird-1}}}\moddef{debug inputs and outputs~{\nwtagstyle{}\subpageref{NW3fNyKO-4Fird-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-41HQ4C-1}}\nwenddeflinemarkup
if (debug) \{
    cat(paste("inputs: ", paste(inputs, collapse=", "), "\\n"))
    cat(paste("outputs: ", paste(outputs, collapse=", "), "\\n"))
    cat(paste("updates: ", paste(updates, collapse=", "), "\\n"))
\}
\nwused{\\{NW3fNyKO-41HQ4C-1}}\nwendcode{}\nwbegindocs{56}\nwdocspar

\nwenddocs{}\nwbegincode{57}\sublabel{NW3fNyKO-4RCJKm-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-4RCJKm-1}}}\moddef{debug time and dependency databases~{\nwtagstyle{}\subpageref{NW3fNyKO-4RCJKm-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-41HQ4C-1}}\nwenddeflinemarkup
if (debug) \{
    cat("Time stamp database:\\n")
    print(sapply(ls(timeDB), get, envir=timeDB))
    cat("Dependencies database:\\n")
    print(sapply(ls(depDB), get, envir=depDB))
\}
\nwused{\\{NW3fNyKO-41HQ4C-1}}\nwendcode{}\nwbegindocs{58}\nwdocspar

\subsection{Batch mode}

If the {\Tt{}infile\nwendquote} argument to {\Tt{}safemode()\nwendquote} is non-{\Tt{}NULL\nwendquote},
we open a file to read from (rather than reading from the command line).

\nwenddocs{}\nwbegincode{59}\sublabel{NW3fNyKO-3M0wdx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-3M0wdx-1}}}\moddef{init batch mode~{\nwtagstyle{}\subpageref{NW3fNyKO-3M0wdx-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-2jP4FB-1}}\nwenddeflinemarkup
con <- file(infile, "r")
\nwused{\\{NW3fNyKO-2jP4FB-1}}\nwendcode{}\nwbegindocs{60}\nwdocspar

In batch mode, we read from the connection rather than from the command line.

\nwenddocs{}\nwbegincode{61}\sublabel{NW3fNyKO-4Qk14X-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-4Qk14X-1}}}\moddef{batch read~{\nwtagstyle{}\subpageref{NW3fNyKO-4Qk14X-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-XzPhD-1}}\nwenddeflinemarkup
\nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1} <- c(\nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1}, readLines(con, n=1))
\nwused{\\{NW3fNyKO-XzPhD-1}}\nwidentuses{\\{{\nwixident{cmd}}{cmd}}}\nwindexuse{\nwixident{cmd}}{cmd}{NW3fNyKO-4Qk14X-1}\nwendcode{}\nwbegindocs{62}\nwdocspar

In batch mode, comments are echoed to stdout.

\nwenddocs{}\nwbegincode{63}\sublabel{NW3fNyKO-1r17xi-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1r17xi-1}}}\moddef{batch comment~{\nwtagstyle{}\subpageref{NW3fNyKO-1r17xi-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-XzPhD-1}}\nwenddeflinemarkup
cat(paste0("safe> ", \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1}), "\\n")
\nwused{\\{NW3fNyKO-XzPhD-1}}\nwidentuses{\\{{\nwixident{cmd}}{cmd}}}\nwindexuse{\nwixident{cmd}}{cmd}{NW3fNyKO-1r17xi-1}\nwendcode{}\nwbegindocs{64}\nwdocspar

In batch mode, blank lines are echoed to stdout.

\nwenddocs{}\nwbegincode{65}\sublabel{NW3fNyKO-VjREX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-VjREX-1}}}\moddef{batch blank line~{\nwtagstyle{}\subpageref{NW3fNyKO-VjREX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3UyNT8-1}}\nwenddeflinemarkup
cat("\\n")
\nwused{\\{NW3fNyKO-3UyNT8-1}}\nwendcode{}\nwbegindocs{66}\nwdocspar

In batch mode, we echo the expression text to stdout.

\nwenddocs{}\nwbegincode{67}\sublabel{NW3fNyKO-2EECxy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-2EECxy-1}}}\moddef{batch expression~{\nwtagstyle{}\subpageref{NW3fNyKO-2EECxy-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-ujlbC-1}}\nwenddeflinemarkup
cat(paste0(c("safe> ",
             rep("safe+ ",
                 max(0, length(\nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1}) - 1))),
           \nwlinkedidentc{cmd}{NW3fNyKO-2jP4FB-1}), sep="\\n")
\nwused{\\{NW3fNyKO-ujlbC-1}}\nwidentuses{\\{{\nwixident{cmd}}{cmd}}}\nwindexuse{\nwixident{cmd}}{cmd}{NW3fNyKO-2EECxy-1}\nwendcode{}\nwbegindocs{68}\nwdocspar

In batch mode, we must close the input connection.

\nwenddocs{}\nwbegincode{69}\sublabel{NW3fNyKO-1ObEmC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1ObEmC-1}}}\moddef{batch shut down~{\nwtagstyle{}\subpageref{NW3fNyKO-1ObEmC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-2jP4FB-1}}\nwenddeflinemarkup
close(con)
\nwused{\\{NW3fNyKO-2jP4FB-1}}\nwendcode{}\nwbegindocs{70}\nwdocspar

\subsection{Miscellany}
\label{sec:miscellany}

The following function does a quick-and-dirty check of whether a user
typed {\Tt{}q()\nwendquote} at the command prompt.  It is rather easy to defeat
this.  For example, typing {\Tt{}(q())\nwendquote} will cause an immediate exit
from R.

\nwenddocs{}\nwbegincode{71}\sublabel{NW3fNyKO-1LAAIJ-A}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-A}}}\moddef{support functions~{\nwtagstyle{}\subpageref{NW3fNyKO-1LAAIJ-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwprevnextdefs{NW3fNyKO-1LAAIJ-9}{\relax}\nwenddeflinemarkup
\nwlinkedidentc{isQuitCall}{NW3fNyKO-1LAAIJ-A} <- function(e) \{
    (!inherits(e, "error") &&
      length(e) == 1 &&
      deparse(e[[1]], nlines = 1) == "q()")
\}
\nwindexdefn{\nwixident{isQuitCall}}{isQuitCall}{NW3fNyKO-1LAAIJ-A}\eatline
\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwidentdefs{\\{{\nwixident{isQuitCall}}{isQuitCall}}}\nwendcode{}\nwbegindocs{72}\nwdocspar
\subsection{Comments and copyright}
\label{sec:comments-and-copyright}

\nwenddocs{}\nwbegincode{73}\sublabel{NW3fNyKO-4FQ1cJ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3fNyKO-4FQ1cJ-1}}}\moddef{comments-and-copyright~{\nwtagstyle{}\subpageref{NW3fNyKO-4FQ1cJ-1}}}\endmoddef\let\nwnotused=\nwoutput{}\nwstartdeflinemarkup\nwusesondefline{\\{NW3fNyKO-3xdkHW-1}}\nwenddeflinemarkup
###  Original code and documentation copyright Ross Ihaka, 2011
### 
###  Modifications copyright Paul Murrell, 2015
###
###  Distributed under the terms of GPL3, but may also be
###  redistributed under any later version of the GPL.
###
###  DO NOT edit this file directly.
###  This R code was generated from a literate document;
###  all changes should be made to that literate document.
###
###  Safe mode for R
###
###  Synopsis:
###
###  This function provides an environment that provides some 
###  protection from stupidity arising from laziness
###
###    safemode()
###    ...
###    q()
###
###  Exit from safe mode using using q()
###
###  This is best regarded as an exercise in getting familar
###  with R's condition system and a demonstration of how
###  to write an interpreted REPL and an exploration of 
###  the 'codetools' and 'CodeDepends' packages.

\nwused{\\{NW3fNyKO-3xdkHW-1}}\nwendcode{}

\nwixlogsorted{c}{{batch blank line}{NW3fNyKO-VjREX-1}{\nwixu{NW3fNyKO-3UyNT8-1}\nwixd{NW3fNyKO-VjREX-1}}}%
\nwixlogsorted{c}{{batch comment}{NW3fNyKO-1r17xi-1}{\nwixu{NW3fNyKO-XzPhD-1}\nwixd{NW3fNyKO-1r17xi-1}}}%
\nwixlogsorted{c}{{batch expression}{NW3fNyKO-2EECxy-1}{\nwixu{NW3fNyKO-ujlbC-1}\nwixd{NW3fNyKO-2EECxy-1}}}%
\nwixlogsorted{c}{{batch read}{NW3fNyKO-4Qk14X-1}{\nwixu{NW3fNyKO-XzPhD-1}\nwixd{NW3fNyKO-4Qk14X-1}}}%
\nwixlogsorted{c}{{batch shut down}{NW3fNyKO-1ObEmC-1}{\nwixu{NW3fNyKO-2jP4FB-1}\nwixd{NW3fNyKO-1ObEmC-1}}}%
\nwixlogsorted{c}{{call the read-eval-print-loop}{NW3fNyKO-nYuTh-1}{\nwixu{NW3fNyKO-or39s-1}\nwixd{NW3fNyKO-nYuTh-1}}}%
\nwixlogsorted{c}{{check for stale symbols in expression}{NW3fNyKO-1i5iWR-1}{\nwixu{NW3fNyKO-4X48TB-1}\nwixd{NW3fNyKO-1i5iWR-1}}}%
\nwixlogsorted{c}{{comments-and-copyright}{NW3fNyKO-4FQ1cJ-1}{\nwixu{NW3fNyKO-3xdkHW-1}\nwixd{NW3fNyKO-4FQ1cJ-1}}}%
\nwixlogsorted{c}{{debug globals}{NW3fNyKO-2ZXfip-1}{\nwixu{NW3fNyKO-24swck-1}\nwixd{NW3fNyKO-2ZXfip-1}}}%
\nwixlogsorted{c}{{debug inputs and outputs}{NW3fNyKO-4Fird-1}{\nwixu{NW3fNyKO-41HQ4C-1}\nwixd{NW3fNyKO-4Fird-1}}}%
\nwixlogsorted{c}{{debug time and dependency databases}{NW3fNyKO-4RCJKm-1}{\nwixu{NW3fNyKO-41HQ4C-1}\nwixd{NW3fNyKO-4RCJKm-1}}}%
\nwixlogsorted{c}{{determine tracked symbols in expression}{NW3fNyKO-24swck-1}{\nwixu{NW3fNyKO-4X48TB-1}\nwixd{NW3fNyKO-24swck-1}}}%
\nwixlogsorted{c}{{evaluate expression in safe mode}{NW3fNyKO-4X48TB-1}{\nwixu{NW3fNyKO-ujlbC-1}\nwixd{NW3fNyKO-4X48TB-1}}}%
\nwixlogsorted{c}{{handle special expression cases}{NW3fNyKO-3UyNT8-1}{\nwixu{NW3fNyKO-3mTANZ-1}\nwixd{NW3fNyKO-3UyNT8-1}}}%
\nwixlogsorted{c}{{handle the expression}{NW3fNyKO-3mTANZ-1}{\nwixu{NW3fNyKO-N1orb-1}\nwixd{NW3fNyKO-3mTANZ-1}}}%
\nwixlogsorted{c}{{handle the general expression case}{NW3fNyKO-ujlbC-1}{\nwixu{NW3fNyKO-3mTANZ-1}\nwixd{NW3fNyKO-ujlbC-1}}}%
\nwixlogsorted{c}{{handle the results of the parse}{NW3fNyKO-N1orb-1}{\nwixu{NW3fNyKO-XzPhD-1}\nwixd{NW3fNyKO-N1orb-1}}}%
\nwixlogsorted{c}{{init batch mode}{NW3fNyKO-3M0wdx-1}{\nwixu{NW3fNyKO-2jP4FB-1}\nwixd{NW3fNyKO-3M0wdx-1}}}%
\nwixlogsorted{c}{{initialisation}{NW3fNyKO-3GtYCJ-1}{\nwixu{NW3fNyKO-3xdkHW-1}\nwixd{NW3fNyKO-3GtYCJ-1}}}%
\nwixlogsorted{c}{{interrupt catching}{NW3fNyKO-1uMRLP-1}{\nwixu{NW3fNyKO-2jP4FB-1}\nwixd{NW3fNyKO-1uMRLP-1}}}%
\nwixlogsorted{c}{{main function}{NW3fNyKO-or39s-1}{\nwixu{NW3fNyKO-3xdkHW-1}\nwixd{NW3fNyKO-or39s-1}}}%
\nwixlogsorted{c}{{parse and evaluate expressions}{NW3fNyKO-XzPhD-1}{\nwixu{NW3fNyKO-1uMRLP-1}\nwixd{NW3fNyKO-XzPhD-1}}}%
\nwixlogsorted{c}{{read-eval-print loop}{NW3fNyKO-2jP4FB-1}{\nwixu{NW3fNyKO-3xdkHW-1}\nwixd{NW3fNyKO-2jP4FB-1}}}%
\nwixlogsorted{c}{{record time stamps and dependencies}{NW3fNyKO-41HQ4C-1}{\nwixu{NW3fNyKO-4X48TB-1}\nwixd{NW3fNyKO-41HQ4C-1}}}%
\nwixlogsorted{c}{{safemode.R}{NW3fNyKO-3xdkHW-1}{\nwixd{NW3fNyKO-3xdkHW-1}}}%
\nwixlogsorted{c}{{shut down}{NW3fNyKO-2lz4JN-1}{\nwixu{NW3fNyKO-or39s-1}\nwixd{NW3fNyKO-2lz4JN-1}}}%
\nwixlogsorted{c}{{support functions}{NW3fNyKO-1LAAIJ-1}{\nwixu{NW3fNyKO-3xdkHW-1}\nwixd{NW3fNyKO-1LAAIJ-1}\nwixd{NW3fNyKO-1LAAIJ-2}\nwixd{NW3fNyKO-1LAAIJ-3}\nwixd{NW3fNyKO-1LAAIJ-4}\nwixd{NW3fNyKO-1LAAIJ-5}\nwixd{NW3fNyKO-1LAAIJ-6}\nwixd{NW3fNyKO-1LAAIJ-7}\nwixd{NW3fNyKO-1LAAIJ-8}\nwixd{NW3fNyKO-1LAAIJ-9}\nwixd{NW3fNyKO-1LAAIJ-A}}}%
\nwixlogsorted{c}{{warning state variables}{NW3fNyKO-4ZejqA-1}{\nwixu{NW3fNyKO-3xdkHW-1}\nwixd{NW3fNyKO-4ZejqA-1}}}%
\nwixlogsorted{i}{{\nwixident{cmd}}{cmd}}%
\nwixlogsorted{i}{{\nwixident{displayWarnings}}{displayWarnings}}%
\nwixlogsorted{i}{{\nwixident{handleError}}{handleError}}%
\nwixlogsorted{i}{{\nwixident{handleParseError}}{handleParseError}}%
\nwixlogsorted{i}{{\nwixident{handleValue}}{handleValue}}%
\nwixlogsorted{i}{{\nwixident{incompleteParse}}{incompleteParse}}%
\nwixlogsorted{i}{{\nwixident{isQuitCall}}{isQuitCall}}%
\nwixlogsorted{i}{{\nwixident{newwarnings}}{newwarnings}}%
\nwixlogsorted{i}{{\nwixident{nwarnings}}{nwarnings}}%
\nwixlogsorted{i}{{\nwixident{prompt}}{prompt}}%
\nwixlogsorted{i}{{\nwixident{renewwarnings}}{renewwarnings}}%
\nwixlogsorted{i}{{\nwixident{repl}}{repl}}%
\nwixlogsorted{i}{{\nwixident{tryCatchWithWarnings}}{tryCatchWithWarnings}}%
\nwixlogsorted{i}{{\nwixident{warningCalls}}{warningCalls}}%
\nwixlogsorted{i}{{\nwixident{warningMessages}}{warningMessages}}%
\nwbegindocs{74}\nwdocspar

\newpage
\section*{Chunk Index}
\label{sec:chunk-index}

\nowebchunks

\newpage
\section*{Identifier Index}
\label{sec:identifier-index}

\nowebindex

\end{document}
\nwenddocs{}
